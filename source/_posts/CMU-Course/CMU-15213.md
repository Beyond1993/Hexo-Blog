---
title: CMU-15213
date: 2017-10-16 06:03:13
categories: CMU
tags:
---

## 第一章　

holle.c
1.一个字节8位，每个字节表示程序中某个文本字符。
2.系统中所有信息，都是一串位表示，区分不同数据对象唯一方法就是上下文。
3.通常总线被设计成传送定长的字节块，字（word)，字中的字节数是一个基本系统参数，有4字节（32位),8字节(64位）
4.虚拟存储器为每一个进程提供了一个假象，每个进程都在独占的使用主存

## 第二章 信息存储与表示

无符号数（unsigned）基于传统二进制表示，表示大于等于0的数字

补码（two’s-complement）编码是表示有符号整数的最常见方式，可以为正或负

浮点数（float-point）编码是表示实数的科学计数法的以二进制为基数的版本。

注：原码，反码，补码，移码 简单求解

原码：

如果机器字长为n，那么一个数的原码就是一个n位的二进制数有符号数，其中最高位为符号位：正数为0，负数为1。剩下的n-1位为数值位，表示真值的绝对值。凡不足n-1位的，小数在最低位右边加零；整数则在最高位左边加零来补足n-1位。

例如：X = +101011，[X]原 = 0010 1011；X = -101011，[X]原 = 1010 1011。注意：正数的原、反、补码都一样。0的原码跟反码都有两个，因为这里0被分为+0和-0。

反码：知道了原码，那么你只需要具备区分0跟1的能力就可以轻松求出反码。因为

反码就是在原码的基础上，符号位不变，其他位按位取反（就是0变1，1变0）就可以了。 例如：X = -101011，[X]原 = 1010 1011，[X]反 = 1101 0100。

补码：补码也非常简单，就是在反码的基础上，按照正常的加法运算加1。 例如：X = -101011，[X]原 = 1010 1011 ，[X]反 = 1101 0100，[X]补 = 1101 0101。 也可以在原码的基础上，符号位不变，从右至左遇到第一个1以前（包括这个1）什么都不变，以后按位取反即可。

[X]原 = 1000 0110，[X]补 = 1111 1010 注意：0的补码是唯一的，如果机器字长为8，那么[0]补=0000 0000。

补码和原码的互相转换都是 符号位不变，其他位取反，末位加一。 因为是互补的，补码的补码就是原码

移码：移码最简单了，不管正负数，只要将其补码的符号位取反即可。 例如：X = -101011，[X]原 = 1010 1011，[X]反 = 1101 0100，[X]补 = 1101 0101，[X]移 = 0101 0101

Int 会溢出但结果保持一致。

Float 不会溢出，但结果不一致。

书上两个列子并没有理解。

2.1信息存储

一个byte 有 8 bit作为最小可寻址的存储器单位。每个字节都有唯一数字表示称为地址。

2.1.1 十六进制表示法（hexadecimal,简写为hex）

在C语言中，以0x 或 0X 开头的数字常量表示16进制的值，字符’A’~’F’可大写，可小写，可大小写混合.

小技巧：当值x是2的非负整数n次幂时，x=2^n, 可以将n = i+4j, 0<= i<=3,则该十六进制数的最高位是2^i, 后面跟j个0。 如 512 = 2^9， 9 = 1+4*2，十六进制为 0x200.

2.1.2字(word)

字长（word size） 指明整数和指针数据的nominal size.

每一个虚拟地址都是以字来编码的，字长决定了虚拟地址空间的最大大小。

字长为w, 虚拟地址寻址范围 0~2^w-1, 一次最多访问2^w个字节。

32位机字长为4, 64位机字长为8

(字长是地址的长度，决定了地址所能寻址的范围)

2.1.3 数据大小

Long int 是全字长，所以32位机为 4 byte， 64位机是 8 byte

Long long int 是 64位， 所以都是 8 byte.

一个指针的长度 = 字长 （因为指针就是用来寻址的）

当程序员声明int类型对象存储指针时，在32位机能正常工作，在64位机可能会出问题（因为int 是 4 byte, 指针变成了 8byte）

2.1.4 寻址和字节顺序

大端，小端

2.1.5 表示字符串

ASCII 码 America Standard Code for Information Interchange，

ASCII码有7位码和8位码两种形式。ASCII码划分为两个集合：128个字符的标准ASCII码（7位）和附加的128个字符的扩充和ASCII码（8位）。

Unicode 使用32位表示字符，4 byte 过于浪费空间

所以有些代替编码 将常用字符编码为1或2个byte,不常用的多一些字节

但是UTF-8 每个字符编码为一个字节，和ASCII码保持了一致

UTF-8：

UTF-8 使用一至四个字节为每个字符编码。128 个 ASCII 字符（Unicode 范围由 U+0000 至 U+007F）只需一个字节，带有变音符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及马尔代夫语（Unicode 范围由 U+0080 至 U+07FF）需要二个字节，其他基本多文种平面（BMP）中的字符（CJK属于此类-Qieqie注）使用三个字节，其他 Unicode 辅助平面的字符使用四字节编码。

常规来看，中文汉字在utf-8中到底占几个字节，一般是3个字节，最常见的编码方式是1110xxxx 10xxxxxx 10xxxxxx

GB2312 中每个字符由两个字节表示，然后发现GB2312 不够用，又推出了GBK，全称《汉字内码扩展规范》

2.1.6 表示代码

同样代码不同机器有二进制机器码

二进制机器码一般很少兼容

2.1.7 布尔代数简介

布尔运算 基本操作 与或非

布尔运算 & | ~ ^

逻辑运算 AND OR NOT XOR

命题逻辑 ∧ ∨ ┐

布尔运算的数律

结合律：

交换律：

分布律：

异或（对称差）

A⊕B=A'B + AB'

具体见笔记本数学

此处有题目一 bitXor()

运用德摩根定律  可以 将 与 非 互相转换

a^b = (a|b)&(~a|~b)= ~(~a&~b)&~(a&b) = (a&~b)|(~a&b)

2.1.8 C语言中的位级运算

&|～^ 按位 与，或，非，异或，四种布尔运算能运用在任何整型变量

位级运算的以个常见用法就是实现掩码运算.

异或 相同为0，不同为1

简单理解就是不进位加法，如1+1=0，,0+0=0,1+0=1。

性质

1、交换律 x^y = y^x

2、结合律（即(x^y)^z == x^(y^z)）

3、对于任何数x，都有x^x=0，x^0=x

4、自反性 x^ y ^ y = x ^  0 = x

注：程序员面试宝典上有一题，仅适用异或操作交换两个int变量的值,不使用额外空间, 运用x^x = 0 这一特性

void swap(int *x, int *y){

    *y = *x ^ *y;

    *x = *x ^ *y;// = *x^(*x^*y) = (*x^*x)^*y = 0^*y = *y

    *y = *x ^ *y;// = *y^(*x^*y) = (*y^*y)^*x = 0^*x = *x

}

2.1.9 C语言中的逻辑运算

逻辑运算符 || && ! 和命题逻辑里OR,AND，NOT 对应，很容易与位级运算符混淆

逻辑运算认为所有非零参数true,参数0 为false,结果只返回1和0

位级运算只有在参数被限值成1或0时，才与逻辑运算符有相同功能

逻辑运算符 第一参数能确定表达式的值时，就不会判断后面的参数了，所有条件判断里的条件顺序也是有讲究的。

2.1.10 C语言中的移位运算

左移 << 丢弃高位，右端补零。 又结合律 x<<j<<k <=> (x<<j)<<k

右移 >>

|---逻辑右移，丢弃高位，空位补零，

|---算数右移，丢弃高位，空位补操作数最高位。

2.2 整数表示

2.2.1 整数数据类型

有符号整数的取值范围 -2^(bits-1) ~ （2^bits ）-1

符号位占了一位，0占了一位，所以正数的取值的绝对值比负数少一位。

无符号 0 ~ （2^bits）-1

2,2,2 无符号数的编码

双射

2,2,3 补码编码

我擦。。。。补码直接对应于10进制数，不用把他转为原码！！

补码，原码，反码都是表示有符号数的一种方式。

但是原码和补码都有一种奇怪的属性，[00…0] 都为 +0，

-0 在原码中[10…0],在反码中[11…1]

但在补码中 +0,-0 均为[00…0]

几乎现代所有机器均使用补码，反码几乎不用，在浮点数中有使用原码编码。

此处有题，是否是最小的补码 isTmin [10…0]

tmin : 1<<31

isTmin: !(x+x)&!!(x)

编程小技巧:使用双感叹号!!，将非0值转为1,0继续保持为0。

http://www.cnblogs.com/organic/archive/2015/12/06/5023038.html

http://www.zybang.com/question/23ea81821a0ff434453509053fb75458.html

http://zhidao.baidu.com/link?url=IIRtgeHXW-oj8FyFxQVYwy_cQ00Rui3yuKwXnF7KKny8DDTBFElUicKs058GRUIJJg4F4jWQbgfJnXoojQug7_

http://blog.csdn.net/tzh476/article/details/51284938

http://blog.csdn.net/kqzxcmh/article/details/11845165 


