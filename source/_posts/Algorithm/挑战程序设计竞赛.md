---
title: 挑战程序设计竞赛
date: 2017-11-21 18:55:14
categories: Algorithm
tags:
---

第1章 蓄势待发 -- 准备篇

1.6 轻松热身
1.6.1 先从简单题开始
题目描述： 有 n 根棍子，棍子的长度为ai. 找出三根棍子组成三角形的周长。组成不了三角形输出0
e.g. input: n= 5, a = {2,3,4,5,10} 

1.6.2 POJ的题目Ants
1.6.3 难度增加的抽签问题

第2章 初出茅庐 -- 初级篇

2.1 最基础的“穷竭搜索"

2.3 一往直前！贪心算法

2.3 记录结果再利用的“动态规划”

### 2.3.1 记忆话搜索与动态规划
#### 01 背包问题

有n个重量和价值分别为wi, vi 的物品。 从这些物品中挑选出总重量不超过W的物品，求所有挑选方案中价值总和的最大值。

####  最长公共子序列 (LCM)

### 2.3.2 进一步探讨递推关系

#### 完全背包问题 （物品任意件）

####  0 1 背包问题 2 ，改变限制条件

有 n 个重量和价值分别为Wi, Vi的物品。从这些物品中挑选出总重量不超过W的物品，求所有挑选方案中价值总和的最大值。

1 <= n <= 100
1 <= Wi,Vi <= 100
1 <= W <= 10000

输入 
n = 4
(w,v) = { (2,3), (1,2) , (3,4), (2,2)) }
W = 5

输出 
7 (选择 0 ,1 ,3 号物品)

用最直观的DFS 解法

```cpp
int n, W
int w[MAX_N], v[MAX_N]

// 从第i个物品开始挑选总重小于j的部分
int rec(int i, int j) {
  int res;
  if (i == n) {
    //已经没有剩余物品了
    res = 0;
  } else if ( j < w[i]) {
    res = rec( i + 1, j);
  } else {
    res = max(rec(i + 1, j), rec( i + 1, j - w[i]) + v[i]);
  }
  return res;
}

void solve() {
  printf("%d\n",rec(0, W));
}
```

这种方法的搜索深度是n,而且每一层的搜索都需要两次分支，最坏就需要O(2^n) 

以前老是分不清，遍历一颗二叉树的DFS，和这种搜索的DFS的差别.

现在总算搞清楚了，二叉树的DFS, 是每个节点遍历，有且仅有一次。但是搜索的空间是所有可能性，所以是指数形式的。

#### 多重部分和问题

#### 最长上升子序列问题

有一个长为n的数列 a0, a1, ..., an-1。 请求出这个序列中最长的上升子序列的长度。 

### 2.3.3 有关计数问题的DP

#### 划分数

#### 多重集组合数





2.4 加工并存储数据的数据结构

2.5 它们其实都是"图"



## 第3章 出类拔萃 -- 中级篇
### 3.3 活用各种数据结构
#### 3.3.1 线段树
**线段树的概念**
线段树是一棵完全二叉树,树上每个节点都维护一个区间。根维护的是整个区间，每个节点维护的是父亲的区间二等分后的其中一个区间. 当有n个元素时，对区间的操作可以在O(log n)的时间内完成。

![](http://images.cnitblog.com/blog/517264/201312/01204058-426dce8b8a05491b91edeba9ec2e4112.jpg)

根据节点中维护的数据不同，线段树可以提供不同的功能。

**基于线段树的RMQ(Range Minimum Query)的结构**

##### 1. 线段树的概念
#### 3.3.2 Binary Indexed Tree
#### 3.3.3 分桶法和平方分割
7. 需要运用平方分割的题目
K-th Number 
给定一个数列 a1, a2, ..., an 和 m 个三元组表示的查询。对于每个查询(i,j,K), 输出ai, ai+1, ..., aj 的升序排列中的第k个数

限制条件
n <= 100000, m <= 5000
|ai| <= 10 ^ 9

```cpp
const int B = 1000; 
int N, M;
int A[MAX_N];
int I[MAX_M], J[MAX_M], K[MAX_M];

int nums[MAX_N]; // 对A排序之后的结果
vector<int> bucket[MAX_N / B] //每个桶排序之后的结果

void solve() {
  for (int i = 0; i < N; i++) {
    bucket[i /B].push_back(A[i]);
    nums[i] = A[i];
  }
  sort(nums, nums + N);
  // 虽然每B个一组剩下的部分所在的桶没有排序, 但是不会产生问题
  for (int i = 0; i < N /B; i++) sort(bucket[i].begin(), bucket[i].end());

  for (int i = 0; i < M; i++) {
    int l = I[i], r = J[i] + 1, k = K[i];
    int lb = -1, ub = N - 1;
    while(ub - lb > 1) {
      int md = (lb + ub) / 2;
      int x = nums[md];
      int t1 = l, tr = r, c = 0;
      
      // 区间两端多出的部分
      while (tl < tr && t1 % B != 0) if (A[tl++] <= x) c++;
      while (tl < tr && tr % B != 0) if (A[--tr] <= x) c++;

      // 对每一桶进行计算
      while (tl < tr) {
        int b = t1 / B;
        c += upper_bound(bucket[b].begin(), bucket[b].end(), x) - bucket[b].begin();
        tl += B;
      }
      if (c >= k) ub = md;
      else lb = md; 
    }
    printf("%d\n", nums[ub]);
  }
}
```

### 3.5 借助水流解决问题的网络流
#### 3.5.1 最大流
#### 3.5.2 最小割
#### 3.5.3 二分图匹配
#### 3.5.4 一般图匹配
#### 3.5.5 匹配，边覆盖，独立集和顶点覆盖


第4章 登峰造极 -- 高级篇


