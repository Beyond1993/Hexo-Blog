---
title: 挑战程序设计竞赛
date: 2017-11-21 18:55:14
categories: Algorithm
tags:
---

第1章 蓄势待发 -- 准备篇

1.6 轻松热身
1.6.1 先从简单题开始
题目描述： 有 n 根棍子，棍子的长度为ai. 找出三根棍子组成三角形的周长。组成不了三角形输出0
e.g. input: n= 5, a = {2,3,4,5,10} 

1.6.2 POJ的题目Ants
1.6.3 难度增加的抽签问题

第2章 初出茅庐 -- 初级篇

2.1 最基础的“穷竭搜索"

2.3 一往直前！贪心算法

2.3 记录结果再利用的“动态规划”

### 2.3.1 记忆话搜索与动态规划
#### 01 背包问题

有n个重量和价值分别为wi, vi 的物品。 从这些物品中挑选出总重量不超过W的物品，求所有挑选方案中价值总和的最大值。

####  最长公共子序列 (LCM)

### 2.3.2 进一步探讨递推关系

#### 完全背包问题 （物品任意件）

####  0 1 背包问题 2 ，改变限制条件

有 n 个重量和价值分别为Wi, Vi的物品。从这些物品中挑选出总重量不超过W的物品，求所有挑选方案中价值总和的最大值。

1 <= n <= 100
1 <= Wi,Vi <= 100
1 <= W <= 10000

输入 
n = 4
(w,v) = { (2,3), (1,2) , (3,4), (2,2)) }
W = 5

输出 
7 (选择 0 ,1 ,3 号物品)

用最直观的DFS 解法

```cpp
int n, W
int w[MAX_N], v[MAX_N]

// 从第i个物品开始挑选总重小于j的部分
int rec(int i, int j) {
  int res;
  if (i == n) {
    //已经没有剩余物品了
    res = 0;
  } else if ( j < w[i]) {
    res = res( i + 1, j);
  } else {
    res = max(rec(i + 1, j), rec( i + 1, j - w[i]) + v[i]);
  }
  return res;
}

void solve() {
  printf("%d\n",rec(0, W));
}
```

这种方法的搜索深度是n,而且每一层的搜索都需要两次分支，最坏就需要O(2^n) 

以前老是分不清，遍历一颗二叉树的DFS，和这种搜索的DFS的差别.

现在总算搞清楚了，二叉树的DFS, 是每个节点遍历，有且仅有一次。但是搜索的空间是所有可能性，所以是指数形式的。

#### 多重部分和问题

#### 最长上升子序列问题

有一个长为n的数列 a0, a1, ..., an-1。 请求出这个序列中最长的上升子序列的长度。 

### 2.3.3 有关计数问题的DP

#### 划分数

#### 多重集组合数





2.4 加工并存储数据的数据结构

2.5 它们其实都是"图"



第3章 出类拔萃 -- 中级篇

第4章 登峰造极 -- 高级篇
