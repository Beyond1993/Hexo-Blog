---
title: 挑战程序设计竞赛
date: 2017-11-21 18:55:14
categories: Algorithm
tags:
---

## 第1章 蓄势待发 -- 准备篇

### 1.6 轻松热身
#### 1.6.1 先从简单题开始
题目描述： 有 n 根棍子，棍子的长度为ai. 找出三根棍子组成三角形的周长。组成不了三角形输出0
e.g. input: n= 5, a = {2,3,4,5,10} 

#### 1.6.2 POJ的题目Ants
1.6.3 难度增加的抽签问题

## 第2章 初出茅庐 -- 初级篇

### 最基础的“穷竭搜索"

### 一往直前！贪心算法

### 记录结果再利用的“动态规划”

#### 记忆话搜索与动态规划
##### 01 背包问题

有n个重量和价值分别为wi, vi 的物品。 从这些物品中挑选出总重量不超过W的物品，求所有挑选方案中价值总和的最大值。

#####  最长公共子序列 (LCM)

#### 2.3.2 进一步探讨递推关系

##### 完全背包问题 （物品任意件）

##### 0 1 背包问题 2 ，改变限制条件

有 n 个重量和价值分别为Wi, Vi的物品。从这些物品中挑选出总重量不超过W的物品，求所有挑选方案中价值总和的最大值。

1 <= n <= 100
1 <= Wi,Vi <= 100
1 <= W <= 10000

输入 
n = 4
(w,v) = { (2,3), (1,2) , (3,4), (2,2)) }
W = 5

输出 
7 (选择 0 ,1 ,3 号物品)

用最直观的DFS 解法

```cpp
int n, W
int w[MAX_N], v[MAX_N]

// 从第i个物品开始挑选总重小于j的部分
int rec(int i, int j) {
  int res;
  if (i == n) {
    //已经没有剩余物品了
    res = 0;
  } else if ( j < w[i]) {
    res = rec( i + 1, j);
  } else {
    res = max(rec(i + 1, j), rec( i + 1, j - w[i]) + v[i]);
  }
  return res;
}

void solve() {
  printf("%d\n",rec(0, W));
}
```

这种方法的搜索深度是n,而且每一层的搜索都需要两次分支，最坏就需要O(2^n) 

以前老是分不清，遍历一颗二叉树的DFS，和这种搜索的DFS的差别.

现在总算搞清楚了，二叉树的DFS, 是每个节点遍历，有且仅有一次。但是搜索的空间是所有可能性，所以是指数形式的。

##### 多重部分和问题

##### 最长上升子序列问题

有一个长为n的数列 a0, a1, ..., an-1。 请求出这个序列中最长的上升子序列的长度。 

#### 2.3.3 有关计数问题的DP

##### 划分数

##### 多重集组合数





### 2.4 加工并存储数据的数据结构

### 2.5 它们其实都是"图"



## 第3章 出类拔萃 -- 中级篇
### 3.3 活用各种数据结构
#### 3.3.1 线段树
**线段树的概念**
线段树是一棵完全二叉树,树上每个节点都维护一个区间。根维护的是整个区间，每个节点维护的是父亲的区间二等分后的其中一个区间. 当有n个元素时，对区间的操作可以在O(log n)的时间内完成。

![](https://images0.cnblogs.com/blog/517264/201312/01204058-426dce8b8a05491b91edeba9ec2e4112.jpg)

根据节点中维护的数据不同，线段树可以提供不同的功能。

**基于线段树的RMQ(Range Minimum Query)的结构**

##### 1. 线段树的概念
#### 3.3.2 Binary Indexed Tree
#### 3.3.3 分桶法和平方分割
7. 需要运用平方分割的题目
K-th Number 
给定一个数列 a1, a2, ..., an 和 m 个三元组表示的查询。对于每个查询(i,j,K), 输出ai, ai+1, ..., aj 的升序排列中的第k个数

限制条件
n <= 100000, m <= 5000
|ai| <= 10 ^ 9

```cpp
const int B = 1000; 
int N, M;
int A[MAX_N];
int I[MAX_M], J[MAX_M], K[MAX_M];

int nums[MAX_N]; // 对A排序之后的结果
vector<int> bucket[MAX_N / B] //每个桶排序之后的结果

void solve() {
  for (int i = 0; i < N; i++) {
    bucket[i /B].push_back(A[i]);
    nums[i] = A[i];
  }
  sort(nums, nums + N);
  // 虽然每B个一组剩下的部分所在的桶没有排序, 但是不会产生问题
  for (int i = 0; i < N /B; i++) sort(bucket[i].begin(), bucket[i].end());

  for (int i = 0; i < M; i++) {
    int l = I[i], r = J[i] + 1, k = K[i];
    int lb = -1, ub = N - 1;
    while(ub - lb > 1) {
      int md = (lb + ub) / 2;
      int x = nums[md];
      int t1 = l, tr = r, c = 0;
      
      // 区间两端多出的部分
      while (tl < tr && t1 % B != 0) if (A[tl++] <= x) c++;
      while (tl < tr && tr % B != 0) if (A[--tr] <= x) c++;

      // 对每一桶进行计算
      while (tl < tr) {
        int b = t1 / B;
        c += upper_bound(bucket[b].begin(), bucket[b].end(), x) - bucket[b].begin();
        tl += B;
      }
      if (c >= k) ub = md;
      else lb = md; 
    }
    printf("%d\n", nums[ub]);
  }
}
```

### 3.5 借助水流解决问题的网络流
#### 3.5.1 最大流
#### 3.5.2 最小割
#### 3.5.3 二分图匹配
#### 3.5.4 一般图匹配
#### 3.5.5 匹配，边覆盖，独立集和顶点覆盖


## 第4章 登峰造极 -- 高级篇
### 找出游戏的必胜策略
#### 4.2.1 游戏与必胜策略

·硬币游戏1
```txt
Alice 和 Bob 在玩这样一个游戏。给定k个s数字 a1,a2,...ak。一开始,有x枚硬币, Alice 和 Bob 轮流取硬币。每次所取硬币的枚数一定要在 a1,a2,...ak 当中。 Alice 先取，取走最后一枚硬币的一方获胜。当双方都采取最优策略时,谁会获胜？ 题目假定 a1,a2,...ak中一定有1。

限制条件
· 1<= x <=10000
· 1<= k <= 100
· 1<= ai <= x
```
输入
```txt
x = 9
k = 2
a= {1, 4}
```
输出
```txt
Alice
```
输入
```txt
x = 10
k = 2
a = {1, 4}
```
输出
```txt
Bob
```
 
定义状态:

win[j] 表示轮到自己时还剩下 j 枚硬币自己的胜负情况。

Alice 先取， win[X] 表示还剩 X 枚硬币，Alice 取时，自己的胜负情况。

```txt
// 输入
int X, K, A[MAX_K]

//动态规划所用的数组
bool win[MAX_X + 1];

void solve() {
  // 轮到自己时没有硬币了,则失败
  win[0] = false;
  
  for (int j = 1; i <= X; j++) {
    // 如果轮到自己时没有硬币，则失败
    win[j] = false;

    // 这个 for 循环表示，只要a1,a2...ak 中有一种取法能获胜,就说明这个状态下我可以赢。
    // 而这个状态下获胜的条件是 剩下的硬币数量不少于我要取的。 并且我取完之后剩下的是失败状态.
    // 如果 硬币数量 过少。 也就是 j < A[i]，题目里规定肯定有一个1，所以这种情况不会出现.
    // 硬币数量过少，一把就取走了，所以就赢了。 
    for (int i = 0; i < K; i++) {
        win[j] |= A[i] <= j && !win[j - A[i]];    
    }
  } 
  
  if (win[X]) puts("Alice");
  else puts("Bob");
}
``` 


