---
title: External-Sort
date: 2017-12-23 07:10:45
categories: Algorithm
tags:
---
http://www.cnblogs.com/LUO77/p/5838206.html

以前一直知道外排这一算法，知道怎么去实现, 以为就像内部排序那样是一个算法，逻辑顺序问题，但是这次面试mircovision, 才发现这个还挺复杂。他更像是一道系统设计题，而不是算法题。

单机处理大文件时，在针对内部排序不能解决的情况，我们可以借助磁盘保存中间结果，再进行归并排序。

所以大体上外排分两步.

1. 将大的文件分成N份小的文件，每一份小文件，进行内部排序。

2. 对有序子文件逐趟归并，使其整个文件有序。

对于 N 份小文件, n / k, n / (k ^ 2), n / (k^3), ... n / (k ^ 4).. 1

虽说最开始的读写是 n 个文件，但是因为是并行的，我们只算一次读写。

这样的话，到最后一次 1 = n / (k ^ m) ==> k ^ m = n, 所以得出归并读写的IO 次数, m = log(k,n) 以 k 为底。

想要减小 m, 就要增大K， 减少n, 


突然发现单机上的外排，和hadoop 集群是多像啊，那个模拟hadoop shuffle 的project，刚好就是这个外排序。 其实也很好理解，增大K, 减少N 的现实意义在减少输入文件个数的同时，增加并发的instance。这里的减少IO 操作，映射到系统中就是减少网络传输。


那么就会出现一个问题： 在K-路归并情况下，依次比较需要O(k) 才能得到结果，我们如果需要找到最终的归并序列，需要至少O(k*n) 的归并次数，在归并路数非常大的情况下，无疑非常的麻烦并且效率很低。


其实一开始只有堆来完成多路归并的，但是人们发现堆每次取出最小值后，把最后一个数放到堆顶，调整堆的时候，每次都要选出父节点的两个孩子节点的最小值，然后利用孩子节点的最小值和父节点进行比较，所以每次调整一层需要两次比较。这样子比较次数太多。

所以想到来， 用胜者树来简化：

  
胜者树，就像一个最小堆

败者树，是一个最大堆， 失败的元素作为根。
