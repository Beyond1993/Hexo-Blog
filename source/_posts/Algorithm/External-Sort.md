---
title: External-Sort
date: 2017-12-23 07:10:45
categories: Algorithm
tags:
---
http://www.cnblogs.com/LUO77/p/5838206.html

以前一直知道外排这一算法，知道怎么去实现, 以为就像内部排序那样是一个算法，逻辑顺序问题，但是通过这次面试, 才发现这个还挺复杂。他更像是一道系统设计题，而不是算法题。

单机处理大文件时，在针对内部排序不能解决的情况，我们可以借助磁盘保存中间结果，再进行归并排序。

所以大体上外排分两步.

1. 将大的文件分成N份小的文件，每一份小文件，进行内部排序。

2. 对有序子文件逐趟归并，使其整个文件有序。

这里的归并排序，也分为三个阶段，一路排序，K-路归并排序，k-路最佳排序树

一路归并:

![](/images/External-Sort.png)

一路排序就是简单的每次扫描所有文件的文件最小元素，选出其中最小值。

当临时文件很多时，这样顺序扫描一遍就很耗时。IO 的读写次数复杂度达到  k * average_n

K-路归并

![](http://c.biancheng.net/cpp/uploads/allimg/120301/1-120301150450U5.jpg)

对于 N 份小文件, n / k, n / (k ^ 2), n / (k^3), ... n / (k ^ 4).. 1

虽说最开始的读写是 n 个文件，但是因为是并行的，我们只算一次读写。

这样的话，到最后一次 1 = n / (k ^ m) ==> k ^ m = n, 所以得出归并读写的IO 次数, m = log(k,n) 以 k 为底。

想要减小 m, 就要增大K， 减少n, 

(单机上的外排，和hadoop 集群是多像啊，那个模拟hadoop shuffle 的project，刚好就是这个外排序。 其实也很好理解，增大K, 减少N 的现实意义在减少输入文件个数的同时，增加并发的instance。这里的减少IO 操作，映射到系统中就是减少网络传输。)

最佳k-路归并树
当每个文件的大小不一致的时候，因为简单的K-路归并效率不高，现在huffman 编码树来合并.

那么就会出现一个问题： 在K-路归并情况下，依次比较需要O(k) 才能得到结果，我们如果需要找到最终的归并序列，需要至少O(k*n) 的归并次数，在归并路数非常大的情况下，无疑非常的麻烦并且效率很低。

如果在进行多路归并的时候，各初始顺串的长度不同，对外存扫描的次数，即执行时间会产生影响。把所有初始顺串的块数作为树的叶结点的权值，如果是K路归并则建立起一棵K-叉Huffman树。这样的一棵Huffman树就是最佳归并树。通过最佳归并树进行多路归并可以使对外存的I/O降到最少,提高归并执行效率。


其实一开始只有堆来完成多路归并的，但是人们发现堆每次取出最小值后，把最后一个数放到堆顶，调整堆的时候，每次都要选出父节点的两个孩子节点的最小值，然后利用孩子节点的最小值和父节点进行比较，所以每次调整一层需要两次比较。这样子比较次数太多。




所以想到来， 用胜者树来简化：
胜者树的原理和堆是相同的，唯一区别是堆的所有节点都是数据节点，而败者树只有叶子节点是数据节点。
  
我们对胜者树进行定义：
1.胜者树是一颗完全二叉树
2.胜者树的叶子结点保存我们的一个输入缓冲区（一路归并顺序表）
3.胜者树的非叶子节点保存当前比较的胜者的输入缓冲区的指针
4.胜者树的根节点保存我们的胜者树当前的的一次比较中的冠军（最优值）

有点像乒乓球小组赛。

**heap 是要和左右节点比较，而胜利树只要和兄弟比较(统一等级的小组比较)，胜利树比堆少了一半的比较次数**




![胜者树](http://img.my.csdn.net/uploads/201210/15/1350310110_2414.jpg)

每次将结果写入缓冲区(或者输出文件) 中，需要在原来位置，重新加入一个，在从下往上调整。

**胜者树，每次都要比较兄弟，但是你要找到兄弟，就必须先找到父节点，才能到兄弟，败者树**

败者树，是一个最大堆， 失败的元素作为根。
1.败者树是一颗完全二叉树
2.败者树的叶子结点保存的是我我们的输入缓冲区
3.败者树的非叶子结点保存我们的当前的比较中败者的对应的输入缓冲区的指针
4.败者树根保存我们的当前比较的亚军，根上面还有一个节点保存我们的冠军

![败者树](http://img.my.csdn.net/uploads/201210/15/1350310705_4079.jpg)


总结
1.在实现将初始文件分为 m 个初始归并段时，为了尽量减小 m 的值，采用置换-选择排序算法，可实现将整个初始文件分为数量较少的长度不等的初始归并段。
2.同时在将初始归并段归并为有序完整文件的过程中，为了尽量减少读写外存的次数，采用构建最佳归并树的方式，对初始归并段进行归并，而归并的具体实现方法是采用败者树的方式。
http://data.biancheng.net/view/79.html
