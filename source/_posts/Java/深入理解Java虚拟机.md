---
title: 深入理解Java虚拟机
date: 2017-12-27 19:19:34
categories: Java
tags:
---

## 前言

## 第一部分

## 第二部分 自动内存管理机制
### 第2章 Java内存区域与内存溢出异常
#### 2.1 概述
不了解虚拟机，一旦爆栈，就很难debug
#### 2.2 运行时数据区域
![](http://fh-1.qiniudn.com/jvm_model.jpg)

#### 2.2.1 程序计数器
### 第3章 垃圾收集器与内存分配策略
#### 3.1 概述
##### 哪些内存需要回收？
jvm对不可用的对象进行回收，哪些对象是可用的，哪些是不可用的？Java并不是采用引用计数算法来判定对象是否可用，而是采用根搜索算法(GC Root Tracing)，当一个对象到GC Roots没有任何引用相连接，用图论的来说就是从GC Roots到这个对象不可达，则证明此对象是不可用的，说明此对象可以被GC。对于这些不可达对象，也不是一下子就被GC，而是至少要经历两次标记过程：如果对象在进行根搜索算法后发现没有与GC Roots相连接的引用链，那它将会第一次标记并且进行一次筛选，筛选条件是此对象有没有必要执行finalize()方法，当对象没有覆盖finalize()方法或者finalize()方法已经被虚拟机调用执行过一次，这两种情况都被视为没有必要执行finalize()方法，对于没有必要执行finalize()方法的将会被GC，对于有必要有必要执行的，对象在finalize()方法中可能会自救，也就是重新与引用链上的任何一个对象建立关联即可。

##### 什么时候回收？
上面说到GC经常发生的区域是堆区，堆区还可以细分为新生代、老年代，新生代还分为一个Eden区和两个Survivor区。

1.1 对象优先在Eden中分配，当Eden中没有足够空间时，虚拟机将发生一次Minor GC，因为Java大多数对象都是朝生夕灭，所以Minor GC非常频繁，而且速度也很快；

1.2 Full GC，发生在老年代的GC，当老年代没有足够的空间时即发生Full GC，发生Full GC一般都会有一次Minor GC。大对象直接进入老年代，如很长的字符串数组，虚拟机提供一个-XX:PretenureSizeThreadhold参数，令大于这个参数值的对象直接在老年代中分配，避免在Eden区和两个Survivor区发生大量的内存拷贝；

1.3 发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则进行一次Full GC，如果小于，则查看HandlePromotionFailure设置是否允许担保失败，如果允许，那只会进行一次Minor GC，如果不允许，则改为进行一次Full GC。
##### 如何回收？
选择不同的垃圾收集器，所使用的收集算法也不同。
在新生代中，每次垃圾收集都发现有大批对象死去，只有少量存活，则使用复制算法，新生代内存被分为一个较大的Eden区和两个较小的Survivor区，每次只使用Eden区和一个Survivor区，当回收时将Eden区和Survivor还存活着的对象一次性的拷贝到另一个Survivor区上，最后清理掉Eden区和刚才使用过的Survivor区，Eden和Survivor的默认比例是8：1，可以使用-XX:SurvivorRatio来设置该比例。
而老年代中对象存活率高，没有额外的空间对它进行分配担保, 必须使用“标记-清理”或“标记-整理”算法


程序计数器，虚拟机栈，本地方法栈3个区域随线程而生，随线程而灭。这几个区域的内存分配和回收都是确定的，不需要考虑线程回收问题。
我们说的内存回收，是针对堆的内存回收。
#### 3.2 对象已死吗
##### 3.2.1 引用计数法(Reference Counting)
给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1，当引用失效时，计数器值减1，计数器为0说明没被引用。简单，高效，但不能解决循环引用问题。

##### 3.2.2 可达性分析算法
在主流的商用程序语言的主流实现中，都是通过可达性分析(Reachability Analysis)来判断对象是否存活，通过"GC Roots"作为起点，开始往下搜，路径称为 (Reference Chain), 当一个对象到GC Roots 没有任何引用链相连时，则证明此对象不可用。
GC Roots
虚拟机栈（栈帧中的本地变量表)中引用的对象。
方法区中类静态属性引用的对象。
本地方法中JNI(Native 方法) 引用的对象。

##### 3.2.3 再谈引用
无论是通过引用计数，还是可达性分析算法，判定对象是否存活都与“引用” 有关。JDK 1.2 以前，Java 中的引用的定义很传统，

### 第4章 虚拟机性能监控与故障处理工具
### 第5章 调优案例分析与实战

## 第三部分

## 第四部分

## 第五部分



