---
title: 0924 Minimize Malware Spread
date: 2025-02-12 10:58:12
categories: LeetCode
tags:
---

问题概述：
给定一个图 graph，表示一个网络，其中 graph[i][j] == 1 表示节点 i 和节点 j 之间有连接，graph[i][j] == 0 表示没有连接。
给定一个初始数组 initial，表示恶意软件最初传播的节点。
任务是返回初始节点中，移除一个节点后，能最小化恶意软件传播的节点。如果有多个节点可以选择，返回索引最小的节点。

解题思路：
图的组件识别：

通过 深度优先搜索 (DFS) 遍历图，找到每个连通组件，并为每个组件分配一个唯一的颜色。
colors[] 数组用于记录每个节点所属的组件颜色。
计算每个组件的大小：

遍历 colors[] 数组，统计每个组件中包含的节点数，保存在 size[] 数组中。
计算每个组件中有多少初始恶意节点：

通过遍历 initial 数组，统计每个组件中有多少恶意节点，保存在 colorCount[] 数组中。
找出移除某个节点后恶意软件传播最小的节点：

遍历 initial 中的节点，检查它是否是其所在组件唯一的恶意节点。如果是，则可以通过移除该节点来减少恶意软件的传播。
如果多个节点有相同的效果（即都能减少恶意软件传播），则选择其所在组件节点数较大的节点；如果组件大小相同，选择索引较小的节点。
处理没有唯一恶意节点的情况：

如果所有初始节点都不是所在组件唯一的恶意节点，则选择 initial 中最小的节点。
时间复杂度：
DFS：这部分的时间复杂度为 
O(N ^2)，因为图是通过邻接矩阵表示，我们需要为每个节点进行深度优先搜索。
后处理：计算组件大小、检查每个节点的恶意节点数量等操作的时间复杂度为O(N)。 因此，整体时间复杂度为 
O(N^2)，其中 𝑁 是节点数。


**大概描述一下，就是要清理网络中的病毒节点，只能清理一个，病毒在相连节点之间可以传播，所以只能清楚那些只有一个病毒节点的
子网络，如果有好几个子网络只有一个病毒节点，返回最小index， 如果所有子网络都有大于等于2 个 病毒节点，选择initial 中最小的。**

```python
from typing import List

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        # 1. 给每个组件上色
        N = len(graph)  # 图的节点数
        colors = [-1] * N  # 每个节点的颜色，-1 表示未访问
        C = 0  # 组件计数

        # 遍历每个节点，对每个未上色的节点执行 DFS，标记连通组件
        for node in range(N):
            if colors[node] == -1:
                self.dfs(graph, colors, node, C)
                C += 1

        # 2. 计算每个组件的大小
        size = [0] * C  # size[i] 表示颜色为 i 的组件的节点数量
        for color in colors:
            size[color] += 1

        # 3. 计算每个组件中有多少初始恶意节点
        colorCount = [0] * C  # colorCount[i] 表示组件 i 中恶意节点的数量
        for node in initial:
            colorCount[colors[node]] += 1

        # 4. 找出最合适的节点
        ans = float('inf')  # 初始值为正无穷，表示未找到答案
        for node in initial:
            c = colors[node]
            if colorCount[c] == 1:  # 只有该组件有一个恶意节点时
                if ans == float('inf'):
                    ans = node  # 找到第一个符合条件的节点
                elif size[c] > size[colors[ans]]:  # 优先选择更大组件的节点
                    ans = node
                elif size[c] == size[colors[ans]] and node < ans:  # 如果组件大小相同，选择索引更小的节点
                    ans = node

        # 如果没有找到唯一的恶意节点，返回 initial 中最小的节点
        if ans == float('inf'):
            for node in initial:
                ans = min(ans, node)

        return ans

    # 深度优先搜索，标记每个节点所在的组件
    def dfs(self, graph: List[List[int]], colors: List[int], node: int, color: int):
        colors[node] = color  # 为当前节点上色
        for nei in range(len(graph)):  # 遍历所有相邻节点
            if graph[node][nei] == 1 and colors[nei] == -1:  # 如果节点相邻且未上色
                self.dfs(graph, colors, nei, color)
```
